
/**
 * cluster: Tests of cluster analysis algorithms.
 *
 * <p>This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */


package org.hermit.test.cluster;


import java.util.Arrays;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.hermit.geometry.Edge;
import org.hermit.geometry.Point;
import org.hermit.geometry.Graph;
import org.hermit.geometry.voronoi.Fortune;


/**
 * Simple Voronoi test scenario.  This class runs a simple Voronoi test,
 * and does a rough check of the results.
 */
public class SimpleTest
    extends TestCase
{
    
    /**
     * Input test points, basically random.
     */
    private static final Point[] INPUT_MEANS = {
        new Point(235,366),
        new Point(60,96),
        new Point(208,194),
        new Point(67,350),
        new Point(192,48),
    };

    /**
     * The edges we expect; generated by observation from a test run.  This
     * array doesn't include the slopes of the semi-infinite lines, so
     * it's just a rough test.
     */
    private static final Point[][] EXPECT_EDGES = {
          { new Point(82.70175581206308,222.47081775321087),
                  new Point(157.47133220910624,290.0510118043845) },
          { new Point(145.97125748502995,126.92095808383233),
                      Point.INFINITE },
          { new Point(82.70175581206308,222.47081775321087),
                      Point.INFINITE },
          { new Point(157.47133220910624,290.0510118043845),
                      Point.INFINITE },
          { new Point(145.97125748502995,126.92095808383233),
                  new Point(3626.5218487394955,-254.50924369747895) },
          { new Point(145.97125748502995,126.92095808383233),
                  new Point(82.70175581206308,222.47081775321087) },
          { new Point(3626.5218487394955,-254.50924369747895),
                      Point.INFINITE },
          { new Point(157.47133220910624,290.0510118043845),
                  new Point(3626.5218487394955,-254.50924369747895) },
    };


    /**
     * Run a test on the simple test data.
     */
    public void testSimple() {
        Graph graph = Fortune.ComputeVoronoiGraph(INPUT_MEANS);
        
        // Convert the expected edges to an array.  Sort for comparison.
        int nedges = EXPECT_EDGES.length;
        Edge[] refEdges = new Edge[nedges];
        for (int i = 0; i < nedges; ++i) {
            Point v1 = EXPECT_EDGES[i][0];
            Point v2 = EXPECT_EDGES[i][1];

            // TODO: we're making up fake datum points here.  Should do this
            // based on the reference line equation.
            refEdges[i] = new Edge(v1, v2, new Point(0, 0), new Point(0, 1));
        }
        Arrays.sort(refEdges);

        // Convert the generated edges to an array and sort.
        Edge[] vEdges = graph.getEdgeArray();
        Arrays.sort(vEdges);

        // Compare the non-infinite edges.  Note that we're only checking
        // the position of the vertices as yet; this is not a complete
        // check in the case of semi-infinite or infinite edges.
        assertEquals("number of edges", refEdges.length, vEdges.length);
        for (int i = 0; i < refEdges.length; ++i)
            if (refEdges[i].compareTo(vEdges[i]) != 0)
                Assert.fail("edge " + i + ": expected " + refEdges[i] + "; got " + vEdges[i]);
    }

}

